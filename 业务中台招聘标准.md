# 业务中台招聘标准

 

# 说明

随着业务快速发展，业务中台&引擎架构组织规模也需要不断扩大，需要有新鲜血液加入共谋大计，完成国际化大满贯的使命。之前招聘面试，没有建立统一面试标准，一面和二面会出现面试内容重复或者面试范围差距较大的情况，因此本手册旨在建立业务中台&引擎架构团队面试标准，拉齐各个职级，面试标准。

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/BDSTgmAm2Vcrry3a/image.png)      

 

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/SLkd9TBVMKQnDRsF/image.png)      

# 第一篇：工程类

## 核心考察点

对工程类同学，核心考察分为四点

1. 基础知识（编程语言、算法、数据结构、网络、操作系统、数据库）
2. 知识宽度（开源项目如Redis、MQ、ES等掌握程度）
3. 项目经历（之前公司所做项目难度和深度，对项目存在问题能够准确描述，有自己的解法，针对业务需求，在技术选型上的考虑）
4. 系统设计和业务知识（对之前业务理解程度，能否根据复杂的业务流程和逻辑进行系统抽象，领域建模能力，是否能够根据自身知识宽度进行合理的系统设计，反思和优化）

PS：D8等高职级可能会设计团队管理相关，但是最好三面重点考察

 

## 权重分布

 

| 职级/知识点 | 基础知识 | 知识宽度 | 项目经历 | 系统设计和业务 |
| ----------- | -------- | -------- | -------- | -------------- |
| D5          | 70%      | 20%      | 10%      | 加分项         |
| D6          | 50%      | 20%      | 20%      | 10%            |
| D7          | 30%      | 30%      | 20%      | 20%            |
| D8          | 10%      | 20%      | 30%      | 40%            |

说明：1、逻辑相关问题，三面重点关注；2、D7/D8如简历存在管理职责，三面重点关注；3、职级越高，项目经历、业务和系统架构能力要求越高

## 面试标准

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/N30IMNaWhnQZ6Q7r/image.png)      

##  如何判断职级

 

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/S5m26YK7Sfs0EMRu/image.png)      

 

 

D5：指导下完成工作（潜力）（功能、性能、异常）

D6：独当一面，负责复杂模块或一个微服务（服务owner）

D7：架构能力，根据业务做技术选型（架构取舍）

D8：系统架构，系统演进（架构师）

##  面试评价

*立场鲜明，**言简意赅，粗中有细*

 

**立场鲜明**：必须给出明确的立场，通过还是不通过，面试评价不得模棱两可，如果通过重点描述后续人优势，如果不通过，则重点描述后续人需要提升的地方

**言简意赅：**面试评价不是记流水账，整体评价需要言简意赅的说明后续人整个面试情况，如因时间原因，部分未考察到，可在面评中体现下一轮面试官重点考察

**粗中有细：**面试评价不能过于笼统，需要体现面试细节，需要将面试过程中考察了候选人哪些面试题，候选人回答情况以及每个题目的回答情况做简要点评

总结下来，整个面试评价应该包含如下

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/5L2wpYGS6Tct9oVJ/image.png)      

**示例**

**Bad Case**

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/PbEtuuyrnF4wlXB0/image.png)      

 

Good case

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/uFrAXevveqY9oPqS/image.png)      

# 第二篇：算法类

## 核心考察点

1. 知识：主要是候选人对machine learning相关知识和理论的储备
2. 工具：候选人将machine learning知识应用于实际业务的工具
3. 逻辑：候选人的举一反三的能力，解决问题的条理性，发散思维的能力，你的聪明程度
4. 业务：深入理解所在行业的商业模式，从业务中发现motivation并进而改进模型算法的能

广告算法工程师举例

知识：主流CTR模型以及预算控制，流量预估，bidding策略等模型算法的原理和技术细节

工具：coding能力，spark、Flink、tensorflow、ps-lite等模型训练、serving相关工具

逻辑：算法题，模型之间的演化关系

业务：展示广告和搜索广告在构建模型时的区别和联系，如何根据公司的business model制定模型的objective

 

参考考点

•知识

•ML基础知识,公式推导等

•基础CS知识(语言,数据结构等

•基础数学知识(概率等

•工具

•基础coding

•大数据相关基础工具,spark,SQL,HIVE等

•ML相关基础工具,TF等

•逻辑

•复杂coding

•ML扩展问题

•业务

•项目经历细评

•Task/system design

## 权重分布

 

| 职级/知识点 | 基础知识 | 工具 | 逻辑 | 业务   |
| ----------- | -------- | ---- | ---- | ------ |
| D5          | 40%      | 40%  | 20%  | 加分项 |
| D6          | 20%      | 20%  | 30%  | 20%    |
| D7          | 20%      | 20%  | 30%  | 30%    |
| D8          | 10%      | 15%  | 30%  | 40%    |

说明：1、逻辑相关问题，三面重点关注；2、D7/D8如简历存在管理职责，三面重点关注；3、职级越高，项目经历、业务和系统架构能力要求越高

##  

# 第三篇：面试题库

## 工程篇

### **程序基础**

 **PHP**

1、sort()、asort()、和 ksort() 有什么分别？它们分别在什么情况下使用？

 答案

sort()

 根据阵列中元素的值，以英文字母顺序排序，索引键会由 0 到 n-1 重新编号。主要是当阵列索引键的值无关疼痒时用来把阵列排序。

asort()

 与 sort() 一样把阵列的元素按英文字母顺序来排列，不同的是所有索引键都获得保留，特别适合替联想阵列排序。

 ksort()

 根据阵列中索引键的值， 以英文字母顺序排序，特别适合用于希望把索引键排序的联想阵列。

2、有哪些函数可以用来在现正执行的脚本中插入函式库？

答案

插入 PHP 函式库不外乎 include()、include_once()、require()、require_once()，但细心再想，“函式库”也应该包括 com 物件和 .net 函式库，所以答案也要分别包括 com_load 和 dotnet_load

 

**Go**

1、协程之间的同步

 

2、go语言并发模型

能详细说出go语言MPG模型

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/ANLVVjHzS446pQO9/image.png)              ![img](http://cooper.didichuxing.com/reads3/shimo-images/s95YuWe7ihEN0WHo/image.png)      

 

 

 

context包的用途

context通常被译作上下文，它是一个比较抽象的概念，其本质，是【上下上下】存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine

主协程如何等其余协程完再操作

使用channel进行通信，context,select

slice，len，cap，共享，扩容

append函数，因为slice底层数据结构是，由数组、len、cap组成，所以，在使用append扩容时，会查看数组后面有没有连续内存快，有就在后面添加，没有就重新生成一个大的素组

程序时怎么防止channel没有消费完

**Golang Slice的底层实现**

切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

切片对象非常小，是因为它是只有3个字段的数据结构：

指向底层数组的指针

切片的长度

切片的容量

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/6kdguGTgw8Qm6gFA/image.png)      

 

**sync.Map实现原理，适用的场景**

 

A:go 1.9 官方提供sync.Map 来优化线程安全的并发读写的map。该实现也是基于内置map关键字来实现的。

这个实现类似于一个线程安全的 map[interface{}]interface{} . 这个map的优化主要适用了以下场景：

（1）给定key的键值对只写了一次，但是读了很多次，比如在只增长的缓存中；

（2）当多个goroutine读取、写入和覆盖的key值不相交时。

更进一步，可看sync.Map源码。

​        ![img](https://cooper.didichuxing.com/cooper_gateway/cn/shimo-images/xlqgZTn4VakwFXUU/image.png)      

 

 

**Java**

1、Java的一个List中，存在奇数和偶数，实现一个程序删除其中的偶数

考察集合类是的使用，不能在遍历集合的时候通过集合对象自身带有的删除方法删除元素，只能通过Iterator删除

正确解法：

```
public static void RemoveElement(List<Integer> input) {


    if (null == input || input.size() == 0) {
        return;
    }


    Iterator<Integer> it = input.iterator();
    while (it.hasNext()) {
        Integer val = it.next();
        if (val % 2 == 0) {
            it.remove();
        }
    }
```

2、Java中，在主线程中启动了一个子线程，要求子线程执行完之后，主线程再继续执行

1、将子线程join到主线程中

2、CountdownLaunch

3、CyclicBarrier

4、使用JDK并发包中的Executors框架，ExecutorService的的invokeAll方法调研callable集合，批量执行多个线程，在invokeAll方法结束之后，再执行主线程其他业务逻辑

5、hashmap put原理，扩容机制，get，如何通过hash函数定位到具***置，

6、单例模式介绍，哪几种，实现双重校验的手写；

7、方法里的变量，在JVM哪个区，对象在哪个区

8、spring事务

9、说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

10、谈谈 synchronized 和 ReentrantLock 的区别

1. 两者都是可重入锁

“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。

 

2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

 

3.ReentrantLock 比 synchronized 增加了一些高级功能

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：

等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。

可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。

> Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。

如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准

 

AQS 原理分析

 

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

### **算法**

1、从数组[1，3，2，7]找出和为9的下标

 

 

2、链表每隔N个节点翻转

input: 1->2->3->4->5->6->7->8 n = 3

output: 3->2->1->6->5->4->7->8

 

3、缓存淘汰算法有哪些？实现一个LRU算法

 

4、数据结构，算法题，判断链表有环，找环入口，

 

5、100万个数找最小的10个（大顶堆）

 

6、判断二叉树是否为满二叉树

 

7、使用队列实现栈的下列操作：

push(x) 、pop() 、top() 、empty()

 

 

注意:

 

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。

你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

 

 

8、给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。

 

字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。

注意：子字符串 是字符串中的一个连续字符序列。

 

示例 1：

输入：s = "ababccc"

输出：5

解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。

示例 2：

输入：s = "aba"

输出：2

解释：一种最大拆分方法为 ['a', 'ba'] 。

示例 3：

输入：s = "aa"

输出：1

解释：无法进一步拆分字符串。

 

提示：

1 <= s.length <= 16

s 仅包含小写英文字母

 

 

### **操作系统**

 

1、为什么函数里的变量在函数执行完就无效了？？

答案：

问题其实是如何用栈帧的角度来理解函数以及函数中变量的生命周期、作用域

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/Pal7D3lr9hUaqapM/image.png)              ![img](http://cooper.didichuxing.com/reads3/shimo-images/dYpSCGCBc5wW5L6N/image.png)      

 

**2、内存泄露是怎么回事儿**

 

答案：访问非法的内存空间会引起该错误。常见可能引起的原因：数组越界、野指针、memcopy越界等

内存泄露：内存一直增长，资源回收没做好，如连接未释放、c++的智能指针如果有循环引用会导致内存泄露等等

 

3、进程有哪几种状态?

- 创建状态(new) ：进程正在被创建，尚未到就绪状态。
- 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

**进程间的通信方式**

1. 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. 有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
5. 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

**线程间的同步的方式**

1. 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

**常见的几种内存管理机制**

简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。

1. 块式管理 ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. 页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

**什么是虚拟内存**

虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间

 

**虚拟内存技术的实现呢？**

 

虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：

1. 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. 请求段页式存储管理

这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？

请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。

它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。

不管是上面那种实现方式，我们一般都需要：

1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
2. 缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；
3. 虚拟地址空间 ：逻辑地址到物理地址的变换。

 

 

 

### **网络**

1、TimeWait怎么产生的，有什么危害，怎么防止

 

​        ![img](http://cooper.didichuxing.com/reads3/shimo-images/ZBjUEZ3BoS8Wq6ho/image.png)      

 

谁先关闭谁产生，如果server端来关闭，则产生在server端，会持续2个MSL的时长(一个MSL一般默认30s)

危害： timewait太多可能产生2类报错，timewait溢出或者是无法新建连接(端口号耗尽)， 如果server端产生，则可能引起雪崩，无法服务(例如nginx调用下游服务超时，主动关闭连接，如果访问量很大，可能就产生该问题)

措施：避免server端主动断连接，调大timewait个数或者对相关tcp参数调优

 

2、简单描述一下浏览器输入"[https://www.baidu.com](https://www.baidu.com")",到页面最终展示给用户的过程

 

3、TCP三次握手，两次行不行

 

TimeWait和CloseWait原因

 

TCP 协议如何保证可靠传输

应用数据被分割成 TCP 认为最适合发送的数据块。

 

TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

 

**校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 

TCP 的接收端会丢弃重复的数据。 

**流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

**拥塞控制：** 当网络拥塞时，减少数据的发送。

**停止等待协议** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 

**超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

 

 

4、TCP如何解决网络拥塞

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

 

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

 

**慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

 

**拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.

 

**快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

 

 

 

 

 

### **数据库**

1、三张表

Student(id,name)

Course(id,name)

Score(sid、cid、score)

写一个SQL，找出语文排名第二的学生姓名

答案（考察多表联合查询、排序和分页）：

select c.name from Student as s,Course as c,Score as sc where as.sid=s.id and sc.cid=c.id where c.name="yuwen" order by sc.score desc limit 1,1

 

department（id,name）

 

id name

1  设计

2  市场

3  售后 

 

Employee(id,dptID,name)

1、1,'张三'

2、1,'李四'

3、2,'王五'

4、4,'陈七'

 

/*

用一条SQL语句，怎么显示如下结果

id dptID department name

1  1   设计    张三

2  1   设计    李四

3  2   市场    王五

4  3   售后    彭六

5  4   黑人    陈七

*/

 

答案：

 

SELECT testtable2.* , ISNULL(department,'黑人')

FROM testtable1 right join testtable2 on testtable2.dptID = testtable1.ID

 

 

 

2、简单说说数据库四大特征（ACID）和事务隔离级别

 

2、数据库优化方法

答案

1、看清楚：要优化的点分为三个层面：基础设施（硬件和操作系统配置）；数据库本身（mysql配置，例如innodb_buffer_pool_size配置75%）；业务应用（SQL优化，索引优化、慢查询优化，垂直拆分和水平拆分）

 

3、索引的原理和B+树存储结构

 

Redis的List底层怎么实现的？

 

### **系统设计**

1、设计一个抢红包系统（不能超卖、不能少买）

 

2、设计一个淘宝订单系统，需求（乘客能看自己的订单、商家能看自己出售的订单）

 

### MQ

rocketmq/kafka中消息 至少一次、精确一次、最多一次分别是怎么实现的。

 

## 算法篇

雷霆版本

http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=378602328

### 机器学习算法基础

### 知识

​	回归/分类问题建模差别

​	常见的聚类算法

​	K-means算法原理，常见问题，K值确认，K-means++算法原理

​	MDP-马尔科夫决策过程原理

​	高斯分布/伯努利分布/泊松分布，适合的自然场景或业务场景

​	模特卡洛树算法原理

​	KNN算法原理

​	PCA算法原理和作用

​	model stacking的作用

​	监督学习和非监督学习算法举例

​	softmax算法原理和作用

### 模型

​	LR原理，公式推导

​	SVM原理，常用kernel函数，kernel函数分类特点用途等

​	GBDT/XGBoost原理和对比

​	GBDT一棵树的构建过程，简述一条样本如何通过模型得到预估结果

​	Random Forest算法原理

​	bagging和boosting介绍对比

​	神经网络算法原理，反向传播计算过程

### 目标函数

​	模型的loss function/cost function

​	GBDT/GBRT在分类/回归问题建模时目标函数差异

​	交叉熵损失函数原理

​	二分类最适合的目标函数和原因（交叉熵，凸优化）

​	MAE/RMSE/MAPE等计算公式

### 优化算法

​	常见的优化算法举例

​	momentum/RMSprop/Adam算法公式，原理或效果

​	Adagrad算法原理

​	FTRL算法原理

​	Batch/miniBatch/流失优化算法对比

### 编程语言基础

shell

​	Linux cut/awk/sort/sed

​	文本文档字符串uniq count编程练习

python

​	python对比list/set/dict/tuple

 

C/C++

​	C++封装/继承/多态，进阶：虚函数实现原理，gcc/g++常用参数，内联函数和宏定义有什么区别

​	C语言实现 strlen strcpy，tips：size_t strlen(const char -str) // size_t -> uint，char -strcpy(char -dest, const char -src)

Hadoop & hive

​	MR原理

​	shuffle发生在map之后还是reduce之前

​	MapReduce，GFS，Bigtable论文理解

### 机器学习策略

数据集切分，训练集/测试集/验证集，交叉验证方法

调参方法，GridSearch/RandomSearch，进阶：SMBO/GP（高斯过程）/TPE（Tree-structured Parzen Estimator Approach）

偏差和方差，欠拟合和过拟合，学习曲线

常见模型评估指标

二分类建模评估指标，准确率/召回率/F1-score/AUC

正则化方法，L1，L2，dropout等

dropout原理和numpy实现

batchnorm作用

缺失值如何处理

数据预处理，归一化方法，特征缩放，Scaler(MinMaxScaler/StanderScaler/RobustScaler)

样本不均衡会带来什么问题，常见的处理方法

### NLP

word2vec算法原理，目标函数，采样技巧

TF-IDF算法原理

WordRank算法原理

对比RNN/GRU/LSTM/Transformer

self-attention原理

Bert原理和特点

文本相似度的计算方法举例对比

### 图像处理

解释卷积运算的详细过程

pooling层在做什么，为什么需要做pooling

### 推荐系统与CTR预估

常见业务指标，CTR/CVR/CPC/IVR

问题建模思路（二分类）

排序分数eCTR/eCVR等

为什么需要使用AUC指标

LR/FM/Wide&Deep/DeepFM等对比

DIN/DIEN模型原理和特点

ESMM算法原理

对长尾流量的理解，如果应对

LTR算法原理，point wise/pair wise/list wise

CF-协同过滤算法原理，item based和user based差异

物品冷启动和用户冷启动如何应对

### 系统架构

- 整体架构
- 模块设计
- 数据流转（离线特征，实时特征，离线训练，实时推断）
- 监控指标（离线监控，服务监控，模型性能监控，业务指标监控）
- 业务侧交互方式

### 简历项目

- 项目背景
- 收益预期
- 实际工作，难点挑战
- 项目成果，评估方法
- 总结思考，反思或优化空间

### 编程练习

非平衡二叉树，层次遍历节点值

给定两个有序整型数组，计算中位数，并给出时间复杂度

给定一个整形数组，请找出所有三项相加和为0的数字组合

文本最小编辑距离：两个字符串，计算出str1转换成str2所使用的最小操作数，只能进行如下三种操作，插入一个字符，删除一个字符，替换一个字符

K-means实现

深度优先遍历/广度优先遍历二叉树

 

## 逻辑推理篇

有一个牢房，有3个犯人关在其中。因为玻璃很厚，所以3个人只能互相看见，不能听到 对方说话的声音。” 有一天，国王想了一个办法，给他们每个人头上都戴了一顶帽子，只叫他们知道帽 子的颜色不是白的就是黑的，不叫他们知道自己所戴帽子的是什么颜色的。在这种情况 下，国王宣布两条如下： 1．谁能看到其他两个犯人戴的都是白帽子，就可以释放谁； 2．谁知道自己戴的是黑帽子，就释放谁。 其实，国王给他们戴的都是黑帽子。他们因为被绑，看不见自己罢了。于是他们3个 人互相盯着不说话。可是不久，心眼灵的A用推理的方法，认定自己戴的是黑帽子。您想 ，他是怎样推断的?

 

答案

其中一人，看到两人都是黑的，就会假设，若自己是白的帽子，那另外两个人中的一个（假设B）就能判断出自己带了黑帽子，因为如果不是第三个人就看到了两顶白帽子而会被释放（而他并没说自己看到了两顶白帽），由此第一个人可以推出自己带了黑帽子